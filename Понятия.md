# Ядро (domain + application)

В целом также принято разделять ядро на два отдельных слоя: доменный слой (domain layer) и слой приложений (application layer).

# Домен

Доменный слой - чистое отображение предметной области в код. В основном он представлен доменными сущностями, агрегатами, объектами-значениями, доменными сервисами и доменными ошибками.

# repo
Это то, что работает с данными и проводит над ними круд

# gateway
Это порт, что взаимодействует с внешним миром (не в смысле обязательно с внешним апи или ресурсом, а в смысле за рамками бизнес логики и сущностей) и отдает данные в usecase
repo, например, частный случай gateway

# Сущность (Entity)

Сущность - это по сути контейнер данных, который представляет собой некоторый реальный объект из предметной области. Сущность также содержит поведение, связанное с валидацией полей и управлением собственным состоянием. Принято реализовывать через датаклассы. Если Python >= 3.10, то можно использовать slots=True для оптимизации представления сущностей в памяти.

```python

@dataclass(kwargs_only=True, slots=True)
class Car:
    _id: int | None
    _number: str
    _is_active: bool

    def __post_init__(self):
        """Можно провалидировать поля после создания тут."""

    @classmethod
    def create(cls, vehicle_data) -> 'Car':
        """Либо провалидировать поля и создать объект здесь"""
    
    @property
    def number(self) -> str:
        return self._number
    
    @number.set
    def number(self, value: str) -> None:
        """Вариант 1. Через сеттер"""
        validate(value)
        self._number = value

    def change_number(self, value: str) -> None:
        """Вариант 2. Отдельные бизнес-методы"""
        validate(value)
        self._number = value
    
    def mark_as_active(self) -> None:
        self._is_active = True

    def mark_as_inactive(self) -> None:
        self._is_active = False

```

> P.S. поводу геттеров и сеттеров для валидации не уверен: выглядит громоздко, а потом когда надо маппить сущности к внешним моделям, то вообще мрак. С другой стороны не хотелось бы сюда тащить что-то вроде pydantic или marshmallow (помним - это домен!). Второй вариант тоже представлен: сделать изменение полей "осмысленными" бизнес-методами по типу activate(), change_number() и прочего (и делать валидацию в них). Наверное он даже более 

Важное замечание: сущность является отображением одного понятия предметной области!

# Агрегат (Aggregate)

Окей, теперь мы можем описать объекты предметной области при помощи сущностей. Например мы хотим описать предметную область, связанную с автопарками. У нас есть автопарк, к которому относятся автомобили и механики. Есть следующие бизнес-правила (что-нибудь простое):
1. Название автопарка должно быть длиннее 10 символов
2. Марка и модель машины должна присутствовать в конкретном перечне
3. Стаж механика должен быть больше 3 лет

Классно - это просто валидация полей и инварианты мы спокойно можем соблюсти. Но что, если придет такое требование: на каждые 20 автомобилей в автопарке должен быть как минимум один механик. Проблема в том, что сущности друг о друге не знают (и не должны!), и как реализовать это правило, не смешивая их друг с другом не совсем понятно. Тут на помощь приходят агрегаты. 

Агрегат - это группа сущностей и объектов-значений, которые объединены общими бизнес-правилами. Агрегат обеспечивает консистентость инвариантов для всех сущностей внутри себя. 

У агрегата есть корень (корневая сущность), по которому осуществляется любые операции над ним. О корне можно думать как о сущности со специальной ролью: в другой ситуации она могла бы быть таким же Entity, как и дочерние сущности.

В примере для автопарка мы создадим свой агрегат, куда войдут и автомобили, и механики:

```python

@dataclass
class CarPark:

    _id: int | None  # <- Поля корневой сущности
    _name: str       # <-

    cars: Collection[Car]            # <- Дочерние сущности
    mechanics: Collection[Mechanic]  # <-

    def add_car(self, new_car: Car) -> None:
        """Тут проверяем инвариант с количеством механиков"""

```

Важное замечание: одна сущность должна принадлежать одному агрегату. Если это не так, то агрегат уже не может гарантировать соблюдение инвариантов. Отсюда также следует, что агрегат должен загружаться и сохраняться целиком (в бд он может храниться в виде отдельных таблиц, но в пределах ядра это один объект)!

# Объект-значение (ValueObject)

Бывает, что для описания полей объектов обычных примитивных типов недостаточно (нужно что-то более специфичное для доменной области). Для этого используются объекты-значения.

Value object (VO) - особый примитив домена, который имеет значение с точки зрения бизнеса (может включать дополнительную логику и валидацию). Важно, что у VO нет идентификатора и сравнение происходит по значениям.

Для примера сущности автомобиля можно стоило создать VO "Номер машины", а не валидировать и хранить поля по отдельности:

```python
@dataclass(kwargs_only=True, frozen=True)
class CarNumber:
    number: str
    region: int
    
    def __post_init__(self):
        """Валидация корректности номера и региона"""
```

Стоит отметить, часто удобно использовать как конфигурационные объекты. Например, хотим при старте приложения настроить какой-то класс через json, можно из json сделать list[VO] и скармливать класссу
